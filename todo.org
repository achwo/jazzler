* [#C] Refactoring
** TODO [#A] remove overtone autoloading in autotest
** TODO [#C] in chord, rename :chord to :degree
** TODO [#C] decouple from overtone
** TODO [#C] in key / mode, change format :C3 to :C, as semantically better
** TODO [#C] make test-helper module for useful functions, 
   like overtone-format-test.chord?
** TODO move helpers in player_test to test_helpers
** TODO fix bar creating helper function to have the correct beat numbers
** TODO use standardized usage style / pre-/ post-conditions
* [#B] Research
** TODO what are the correct terms for
*** key / mode
*** elements of bar
** TODO key (~ mode) and key (map) are ambiguous, what to do? 
** DONE when to gen-class?
*** it generates a class from additional parameters
*** only necessary, when we want to use our code from java
* [#A] Features
** TODO [#B] update grammar to use structure field
** DONE [#A] in player.clj, make function to playback song
*** DONE get to work for one figure
*** DONE get to work for more
*** DONE move test helpers to corresponding module
** DONE [#A] update main to play a standard song with no parameters
** TODO Elaborate REPL
*** TODO draw state diagram
*** save and load file
*** close file
*** new song
*** when song open: grammar rules
*** undo and redo
* [#A] Architecture
** TODO [#B] In Repl: have a server in the background
*** it takes commands of the repl, but standardized
    example: incoming is a string progression
    before the server, it gets
**** identified as a progression
**** enhanced by information, that it is a progression
**** then send to the server
**** the returning value is sent back to the client
**** maybe stripped by the enhanced information at the start
** DONE [#A] Think about the architecture of the modules
*** What are possible ways to structure?
**** library as standalone package, imported from repl, gui, overtone player, etc. via leiningen
**** other than that, packages for chords, transformations, notes, parsing, ...
*** What are the main pros and cons of each way?
**** The most important thing is, that we don't have circular dependencies.
**** To achieve that, minimize the dependencies of each module.
**** Ideally, there's only one direction of dependency.
**** To get a structure like that, it's a good idea to structure in a way, that the
     packages go from the most concrete to the most abstract/high-level.
     That way, each package contains only one level of abstraction.
** TODO [#B] generally structure as a server architecture
*** why: we can restart it without ns collisions etc.
*** how: see parens of the dead
** TODO make transformations SOLID
*** one function per transformation
*** composable via ->
* [#B] Workflow
** TODO [#B] Switch files faster in emacs
** TODO [#C] Add lein-ancient to check for outdated deps
** TODO [#B] check out clj-refactor
** TODO [#C] learn to use magit for emacs
** TODO [#B] get to reload everything for midje autotest
*** why: when moving a function to another ns, i have to restart the repl
*** TODO how?
* Bugfixing
** TODO [#A] add duration and beat fields to chords
*** Also, the error message that results is very bad!
**** TODO Add better error handling, possible through preconditions!
** TODO in grammar, allow indentation and generally more whitespace
   
